"""
尽管第一个测试证明了pop(0)操作确实比pop()操作要慢，
但并不能确切的说明pop(0)复杂度为O(n)而pop()的复杂度为O(1)。
为了证实这个结果，我们需要综合不同列表长度的测试结果。
"""
from timeit import Timer

pop_zero = Timer('x.pop(0)', 'from __main__ import x')
pop_end = Timer('y.pop()', 'from __main__ import y')

for i in range(1000000, 10000001, 1000000):
    x = list(range(i))
    pz = pop_zero.timeit(number=1000)

    y = list(range(i))
    pe = pop_end.timeit(number=1000)

    print('%15.5f, %15.5f' % (pz, pe))

"""
        0.32925,         0.00009
        1.08045,         0.00009
        1.71351,         0.00008
        2.53538,         0.00009
        3.34306,         0.00010
        3.95399,         0.00010
        4.75161,         0.00010
        5.44868,         0.00013
        6.09230,         0.00010
        6.75216,         0.00009
"""

"""
可以看到，随着列表的逐渐变长，pop(0)所需要的时间也同样增加。但是pop()的时间却始终保持基本不变。
不出所料，这正是O(n)与O(1)算法的行为。

我们小实验的误差可能来源于我们计算机上同时运行的其他进程。
当我们测量时间时，这些进程可能使我们的代码运行变慢。即使我们试图最小化计算机上其他事情的影响，用时上也总是存在着一定的不确定度。
这就是为什么我们要将测试循环上千次——为了获得足够的信息以使结果具有足够的可信度。
"""
