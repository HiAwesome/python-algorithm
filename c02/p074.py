import timeit
# 这个 import 不可取消，否则 timeit.Timer 无法引入
import random

for i in range(10000, 1000001, 50000):
    t = timeit.Timer('random.randrange(%d) in x' % i, 'from __main__ import random, x')
    # x: List
    x = list(range(i))
    lst_time = t.timeit(number=1000)

    # x: dict
    x = {j: None for j in range(i)}
    d_time = t.timeit(number=1000)

    print('%d, %10.3f, %10.3f' % (i, lst_time, d_time))

"""
10000,      0.076,      0.001
60000,      0.338,      0.001
110000,      0.647,      0.001
160000,      0.913,      0.001
210000,      1.146,      0.001
260000,      1.391,      0.001
310000,      1.793,      0.001
360000,      1.955,      0.001
410000,      2.246,      0.001
460000,      2.645,      0.001
510000,      2.910,      0.001
560000,      3.075,      0.001
610000,      3.583,      0.001
660000,      3.770,      0.001
710000,      3.969,      0.001
760000,      4.843,      0.001
810000,      4.851,      0.001
860000,      4.998,      0.001
910000,      5.854,      0.001
960000,      6.789,      0.001
"""

"""
可以看到，字典始终比列表快，对于最小的只包含10,000个元素的情况，字典比列表快76倍，而在最大的960,000个元素时，字典要快6789倍！
另外可以注意到，随着列表的增大，其包含操作所需要的时间是线性增长的，这证实了我们之前关于其时间复杂度是O(n)的论断。
与此同时，字典的包含操作用时保持不变，即使字典的大小不断变大也是如此。
实际上，10,000个元素的字典的包含操作用了0.001毫秒，而960,000个元素的字典同样也用了0.001毫秒。
"""
