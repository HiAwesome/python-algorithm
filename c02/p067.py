def anagram_solution4(s1, s2):
    """
    解决变位词问题的最后一个方法利用了任何变位词都有相同数量的a，相同数量的b，相同数量的c等等。
    为判断两个字符串是否为变位词，我们首先计算每一个字符在字符串中出现的次数。
    由于共有26个可能的字符，我们可以利用有26个计数器的列表，每个计数器对应一个字符。
    每当我们看到一个字符，就在相对应的计数器上加一。最终，如果这两个计数器列表相同，则这两个字符串是变位词。下面展示了这种方法：

    同样，这个方法有一些循环操作。然而不同于第一个方法，所有循环都不是嵌套的。前两个计数字符数的循环都是n重。
    而因为字符串中总共有26种可能的字符，第三个比较两个计数列表的循环总是执行26步。把它们全部加起来就得到T(n)=2n+26，也就是O(n)。
    这样，我们就找到了一个解决这个问题的线性复杂度的算法。

    在结束这个问题之前，我们需要讨论一些关于空间需求的事情，
    尽管最后一个方法可以以线性的时间复杂度来运行，但是这是以使用了额外的空间来存储两个计数器列表为代价的。
    换句话说，这个算法牺牲了空间来换取时间。

    这是一个常见的现象。很多情况下你需要在时间和空间的权衡中做出选择。
    在这个例子中，额外的空间消耗并不足道。但是如果可能的字母多达几百万种，这将是一个问题。
    作为一个计算机科学家，当要做出算法选择时，需要你根据具体问题来决定利用计算资源的最好方式。


    :param s1: 字符串1
    :param s2: 字符串2
    :return: 两个字符串是否为变位词关系的布尔值
    """
    c1 = [0] * 26
    c2 = [0] * 26

    for i in range(len(s1)):
        pos = ord(s1[i]) - ord('a')
        c1[pos] += 1

    for i in range(len(s2)):
        pos = ord(s2[i]) - ord('a')
        c2[pos] += 1

    j = 0
    still_ok = True

    while j < 26 and still_ok:
        if c1[j] == c2[j]:
            j += 1
        else:
            still_ok = False

    return still_ok


print(anagram_solution4('apple', 'pleap'))

"""
True
"""
